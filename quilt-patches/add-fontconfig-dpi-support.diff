Index: jdk8-tuxjdk/jdk/make/lib/Awt2dLibraries.gmk
===================================================================
--- jdk8-tuxjdk.orig/jdk/make/lib/Awt2dLibraries.gmk
+++ jdk8-tuxjdk/jdk/make/lib/Awt2dLibraries.gmk
@@ -817,7 +817,7 @@ $(eval $(call SetupNativeCompilation,BUI
     LDFLAGS := $(subst -Xlinker -z -Xlinker defs,,$(LDFLAGS_JDKLIB)) $(LDFLAGS_CXX_JDK) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LDFLAGS_SUFFIX := $(BUILD_LIBFONTMANAGER_FONTLIB), \
-    LDFLAGS_SUFFIX_linux := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc, \
+    LDFLAGS_SUFFIX_linux := -lawt $(LIBM) $(LIBCXX) -ljava -ljvm -lc -lfontconfig, \
     LDFLAGS_SUFFIX_solaris := -lawt -lawt_xawt -lc $(LIBM) $(LIBCXX) -ljava -ljvm, \
     LDFLAGS_SUFFIX_macosx := -lawt $(LIBM) $(LIBCXX) -undefined dynamic_lookup \
         -ljava -ljvm, \
Index: jdk8-tuxjdk/jdk/src/share/native/sun/font/freetypeScaler.c
===================================================================
--- jdk8-tuxjdk.orig/jdk/src/share/native/sun/font/freetypeScaler.c
+++ jdk8-tuxjdk/jdk/src/share/native/sun/font/freetypeScaler.c
@@ -38,6 +38,11 @@
 #include FT_SIZES_H
 #include FT_OUTLINE_H
 #include FT_SYNTHESIS_H
+#include FT_LCD_FILTER_H
+
+#include <fontconfig/fontconfig.h>
+#include <X11/Xlib.h>
+#include <malloc.h>
 
 #include "fontscaler.h"
 
@@ -48,6 +53,182 @@
 #define  ROUND(x) ((int) (x+0.5))
 
 typedef struct {
+
+    FT_Render_Mode ftRenderMode;
+    int ftLoadFlags;
+    FT_LcdFilter ftLcdFilter;
+    double verticalDpi;
+    double horizontalDpi;
+
+} RenderingProperties;
+
+static FcPattern* matchedPattern(const FcChar8* family, double ptSize) {
+    /*
+      we will create pattern to find our family and size in
+      fontconfig configuration, and then will return it's
+      properties:
+     */
+    FcPattern* fcPattern = 0;
+    fcPattern = FcPatternCreate();
+    FcValue fcValue;
+    fcValue.type = FcTypeString;
+    fcValue.u.s = family;
+    FcPatternAdd(fcPattern, FC_FAMILY, fcValue, FcTrue);
+    FcPatternAddBool(fcPattern, FC_SCALABLE, FcTrue);
+    FcPatternAddDouble(fcPattern, FC_SIZE, ptSize);
+    // TODO FcPatternAddInteger(pattern, FC_WEIGHT, weight_value);
+    // TODO FcPatternAddInteger(pattern, FC_SLANT, slant_value);
+    // TODO FcPatternAddDouble(pattern, FC_PIXEL_SIZE, size_value);
+    // TODO FcPatternAddInteger(pattern, FC_WIDTH, stretch); 100 in most cases
+    FcConfigSubstitute(0, fcPattern, FcMatchPattern);
+    FcConfigSubstitute(0, fcPattern, FcMatchFont);
+    FcDefaultSubstitute(fcPattern);
+    FcResult res;
+
+    FcPattern *pattern = 0;
+    pattern = FcFontMatch(0, fcPattern, &res);
+    FcPatternDestroy(fcPattern);
+    return pattern;
+}
+
+static void readFontconfig(const FcChar8* family, double ptSize, jint aaType, RenderingProperties* rp) {
+
+    //FcPattern *pattern = matchedPattern((const FcChar8 *) ftFace->family_name);
+    FcPattern *pattern = matchedPattern(family, ptSize);
+
+    int ftLoadFalgs = FT_LOAD_DEFAULT;
+    FT_Render_Mode ftRenderMode;
+    FT_LcdFilter ftLcdFilter;
+    char horizontal = 1;
+    FcBool b;
+
+    // subpixel order:
+    if (aaType == TEXT_AA_ON)
+        ftRenderMode = FT_RENDER_MODE_NORMAL;
+    else if (aaType == TEXT_AA_OFF)
+        ftRenderMode = FT_RENDER_MODE_MONO;
+    else if (FcPatternGetBool(pattern, FC_ANTIALIAS, 0, &b) == FcResultMatch)
+        if (b) {
+            int subpixel = FC_RGBA_UNKNOWN;
+            if (FcPatternGetInteger(pattern, FC_RGBA, 0, &subpixel) == FcResultMatch) {
+                if (subpixel == FC_RGBA_UNKNOWN)
+                    subpixel = FC_RGBA_NONE;
+                switch (subpixel) {
+                    case FC_RGBA_NONE:
+                        ftRenderMode = FT_RENDER_MODE_NORMAL;
+                        break;
+                    case FC_RGBA_RGB:
+                    case FC_RGBA_BGR:
+                        ftRenderMode = FT_RENDER_MODE_LCD;
+                        horizontal = 1;
+                        break;
+                    case FC_RGBA_VRGB:
+                    case FC_RGBA_VBGR:
+                        ftRenderMode = FT_RENDER_MODE_LCD_V;
+                        horizontal = 0;
+                        break;
+                    default:
+                        break;
+                }
+            }
+        } else {
+            ftRenderMode = FT_RENDER_MODE_NORMAL;
+        }
+
+    // loading mode:
+    if (aaType == TEXT_AA_OFF)
+        ftLoadFalgs |= FT_LOAD_TARGET_MONO;
+    else {
+        int hint_style = FC_HINT_NONE;
+        if (FcPatternGetInteger(pattern, FC_HINT_STYLE, 0, &hint_style) == FcResultMatch) {
+            switch (hint_style) {
+                case FC_HINT_NONE:
+                    ftLoadFalgs |= FT_LOAD_NO_HINTING;
+                    break;
+                case FC_HINT_SLIGHT:
+                    ftLoadFalgs |= FT_LOAD_TARGET_LIGHT;
+                    break;
+                case FC_HINT_MEDIUM:
+                    ftLoadFalgs |= FT_LOAD_TARGET_NORMAL;
+                    break;
+                case FC_HINT_FULL:
+                    if (aaType == TEXT_AA_ON)
+                        ftLoadFalgs |= FT_LOAD_TARGET_NORMAL;
+                    else
+                        ftLoadFalgs |= horizontal ? FT_LOAD_TARGET_LCD : FT_LOAD_TARGET_LCD_V;
+                    break;
+                default:
+                    // what else to use as default?
+                    ftLoadFalgs |= FT_LOAD_TARGET_NORMAL;
+                    break;
+            }
+        }
+    }
+
+    // autohinting:
+    if (FcPatternGetBool(pattern, FC_AUTOHINT, 0, &b) == FcResultMatch)
+        if (b)
+            ftLoadFalgs |= FT_LOAD_FORCE_AUTOHINT;
+
+    // LCD filter:
+    int filter = FC_LCD_DEFAULT;
+    if (FcPatternGetInteger(pattern, FC_LCD_FILTER, 0, &filter) == FcResultMatch) {
+        switch (filter) {
+            case FC_LCD_NONE:
+                ftLcdFilter = FT_LCD_FILTER_NONE;
+                break;
+            case FC_LCD_DEFAULT:
+                ftLcdFilter = FT_LCD_FILTER_DEFAULT;
+                break;
+            case FC_LCD_LIGHT:
+                ftLcdFilter = FT_LCD_FILTER_LIGHT;
+                break;
+            case FC_LCD_LEGACY:
+                ftLcdFilter = FT_LCD_FILTER_LEGACY;
+                break;
+            default:
+                // new unknown lcd filter type?! will use default one:
+                ftLcdFilter = FT_LCD_FILTER_DEFAULT;
+                break;
+        }
+    }
+
+    // DPI from fontconfig:
+    double vdpi = 72;
+    double hdpi = 72;
+    if (FcPatternGetDouble(pattern, FC_DPI, 0, &vdpi) == FcResultMatch) {
+        hdpi = vdpi;
+    } else {
+        // no DPI in fontconfig, reading from X:
+        Display* display = XOpenDisplay(NULL); // TODO do we need a display name here?
+        // calculating horizontal resolution:
+        int wmm = DisplayWidthMM(display, 0);
+        int wpx = DisplayWidth(display, 0);
+        // basic formula is:
+        // 25.4 * px / mm + 0.5
+        hdpi = (wpx * 254 + wmm * 5) / (wmm * 10);
+
+        // calculating vertical resolution:
+        int hmm = DisplayHeightMM(display, 0);
+        int hpx = DisplayHeight(display, 0);
+        // basic formula is:
+        // 25.4 * px / mm + 0.5
+        vdpi = (hpx * 254 + hmm * 5) / (hmm * 10);
+
+        // TODO do we need to close display here?
+        XCloseDisplay(display);
+    }
+
+    FcPatternDestroy(pattern);
+
+    rp->ftRenderMode = ftRenderMode;
+    rp->ftLoadFlags = ftLoadFalgs;
+    rp->ftLcdFilter = ftLcdFilter;
+    rp->verticalDpi = vdpi;
+    rp->horizontalDpi = hdpi;
+}
+
+typedef struct {
     /* Important note:
          JNI forbids sharing same env between different threads.
          We are safe, because pointer is overwritten every time we get into
@@ -80,6 +261,7 @@ typedef struct FTScalerContext {
     int        renderFlags;   /* configuration specific to particular engine */
     int        pathType;
     int        ptsz;          /* size in points */
+    RenderingProperties* renderingProperties;
 } FTScalerContext;
 
 #ifdef DEBUG
@@ -412,13 +594,20 @@ static int setupFTContext(JNIEnv *env,
     scalerInfo->font2D = font2D;
 
     if (context != NULL) {
-        FT_Set_Transform(scalerInfo->face, &context->transform, NULL);
 
-        errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, 72, 72);
+        RenderingProperties* rp = (RenderingProperties*)calloc(1, sizeof(RenderingProperties));
+        context->renderingProperties = rp;
+        readFontconfig((const FcChar8 *) scalerInfo->face->family_name, context->ptsz, context->aaType, context->renderingProperties);
 
+        FT_Set_Transform(scalerInfo->face, &context->transform, NULL);
+
+        errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, context->renderingProperties->horizontalDpi, context->renderingProperties->verticalDpi);
         if (errCode == 0) {
             errCode = FT_Activate_Size(scalerInfo->face->size);
         }
+
+        FT_Library_SetLcdFilter(scalerInfo->library, context->renderingProperties->ftLcdFilter);
+
     }
 
     return errCode;
@@ -704,13 +893,8 @@ Java_sun_font_FreetypeFontScaler_getGlyp
         JNIEnv *env, jobject scaler, jobject font2D,
         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 
-    int error, imageSize;
-    UInt16 width, height;
-    GlyphInfo *glyphInfo;
-    int glyph_index;
-    int renderFlags = FT_LOAD_RENDER, target;
-    FT_GlyphSlot ftglyph;
-
+    int error;
+    
     FTScalerContext* context =
         (FTScalerContext*) jlong_to_ptr(pScalerContext);
     FTScalerInfo *scalerInfo =
@@ -726,53 +910,44 @@ Java_sun_font_FreetypeFontScaler_getGlyp
         return ptr_to_jlong(getNullGlyphImage());
     }
 
-    /* if algorithmic styling is required then we do not request bitmap */
-    if (context->doBold || context->doItalize) {
-        renderFlags =  FT_LOAD_DEFAULT;
-    }
-
-    /* NB: in case of non identity transform
-     we might also prefer to disable transform before hinting,
-     and apply it explicitly after hinting is performed.
-     Or we can disable hinting. */
-
-    /* select appropriate hinting mode */
-    if (context->aaType == TEXT_AA_OFF) {
-        target = FT_LOAD_TARGET_MONO;
-    } else if (context->aaType == TEXT_AA_ON) {
-        target = FT_LOAD_TARGET_NORMAL;
-    } else if (context->aaType == TEXT_AA_LCD_HRGB ||
-               context->aaType == TEXT_AA_LCD_HBGR) {
-        target = FT_LOAD_TARGET_LCD;
-    } else {
-        target = FT_LOAD_TARGET_LCD_V;
-    }
-    renderFlags |= target;
-
-    glyph_index = FT_Get_Char_Index(scalerInfo->face, glyphCode);
+    /* TODO
+     * if algorithmic styling is required then we do not request bitmap
+     * if (context->doBold || context->doItalize) {
+     */
 
-    error = FT_Load_Glyph(scalerInfo->face, glyphCode, renderFlags);
+    //FT_UInt glyph_index = FT_Get_Char_Index(scalerInfo->face, glyphCode);
+    //error = FT_Load_Glyph(scalerInfo->face, glyph_index, context->renderingProperties->ftLoadFlags);
+    error = FT_Load_Glyph(scalerInfo->face, glyphCode, context->renderingProperties->ftLoadFlags);
     if (error) {
-        //do not destroy scaler yet.
-        //this can be problem of particular context (e.g. with bad transform)
+        invalidateJavaScaler(env, scaler, scalerInfo);
         return ptr_to_jlong(getNullGlyphImage());
     }
 
-    ftglyph = scalerInfo->face->glyph;
+    FT_GlyphSlot ftglyph = scalerInfo->face->glyph;
+    error = FT_Render_Glyph(ftglyph, context->renderingProperties->ftRenderMode);
+    if (error) {
+        invalidateJavaScaler(env, scaler, scalerInfo);
+        return ptr_to_jlong(getNullGlyphImage());
+    }
 
-    /* apply styles */
-    if (context->doBold) { /* if bold style */
+    /* TODO
+    /* apply styles *//*
+    if (context->doBold) { /* if bold style *//*
         FT_GlyphSlot_Embolden(ftglyph);
     }
-    if (context->doItalize) { /* if oblique */
+    if (context->doItalize) { /* if oblique *//*
         FT_GlyphSlot_Oblique(ftglyph);
     }
-
     /* generate bitmap if it is not done yet
-     e.g. if algorithmic styling is performed and style was added to outline */
+     e.g. if algorithmic styling is performed and style was added to outline *
     if (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE) {
         FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
     }
+     */
+
+    int imageSize;
+    UInt16 width, height;
+    GlyphInfo *glyphInfo;
 
     width  = (UInt16) ftglyph->bitmap.width;
     height = (UInt16) ftglyph->bitmap.rows;
@@ -783,6 +958,7 @@ Java_sun_font_FreetypeFontScaler_getGlyp
         glyphInfo = getNullGlyphImage();
         return ptr_to_jlong(glyphInfo);
     }
+
     glyphInfo->cellInfo  = NULL;
     glyphInfo->managed   = UNMANAGED_GLYPH;
     glyphInfo->rowBytes  = width;
Index: jdk8-tuxjdk/jdk/src/share/classes/javax/swing/UIManager.java
===================================================================
--- jdk8-tuxjdk.orig/jdk/src/share/classes/javax/swing/UIManager.java
+++ jdk8-tuxjdk/jdk/src/share/classes/javax/swing/UIManager.java
@@ -42,10 +42,12 @@ import javax.swing.border.Border;
 
 import javax.swing.event.SwingPropertyChangeSupport;
 import java.beans.PropertyChangeListener;
+import java.io.BufferedInputStream;
 
 import java.io.Serializable;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.InputStream;
 
 import java.util.ArrayList;
 import java.util.Properties;
@@ -190,6 +192,9 @@ public class UIManager implements Serial
     {
         Properties swingProps;
         private UIDefaults[] tables = new UIDefaults[2];
+        
+        @Deprecated
+        int defaultFontSizeTuxjdkSpecific;
 
         boolean initialized = false;
         boolean focusPolicyInitialized = false;
@@ -277,25 +282,6 @@ public class UIManager implements Serial
     }
 
     /**
-     * The location of the <code>swing.properties</code> property file is
-     * implementation-specific.
-     * It is typically located in the <code>lib</code> subdirectory of the Java
-     * installation directory. This method returns a bogus filename
-     * if <code>java.home</code> isn't defined.
-     */
-    private static String makeSwingPropertiesFilename() {
-        String sep = File.separator;
-        // No need to wrap this in a doPrivileged as it's called from
-        // a doPrivileged.
-        String javaHome = System.getProperty("java.home");
-        if (javaHome == null) {
-            javaHome = "<java.home undefined>";
-        }
-        return javaHome + sep + "lib" + sep + "swing.properties";
-    }
-
-
-    /**
      * Provides a little information about an installed
      * <code>LookAndFeel</code> for the sake of configuring a menu or
      * for initial application set up.
@@ -1164,6 +1150,11 @@ public class UIManager implements Serial
             return rv;
         }
     }
+    
+    @Deprecated
+    static public int getDefaultFontSizeTuxjdkSpecific() {
+        return getLAFState().defaultFontSizeTuxjdkSpecific;
+    }
 
 
     /**
@@ -1223,45 +1214,62 @@ public class UIManager implements Serial
             return new Properties();
         }
         else {
-            final Properties props = new Properties();
-
-            java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction<Object>() {
-                public Object run() {
-                    OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());
-                    if (osType == OSInfo.OSType.MACOSX) {
-                        props.put(defaultLAFKey, getSystemLookAndFeelClassName());
+            return java.security.AccessController.doPrivileged(
+                new java.security.PrivilegedAction<Properties>() {
+                public Properties run() {
+                    // if you're not on Linux - you should not apply this patch:
+                    Properties installationWide = null;
+                    Properties systemWide = null;
+                    Properties userWide = null;
+                    
+                    // just for backward compatibility:
+                    String sep = File.separator;
+                    String javaHome = System.getProperty("java.home");
+                    if (javaHome != null) {
+                        installationWide = readPropertiesFromFile(javaHome + "/lib/swing.properties", null);
                     }
-
-                    try {
-                        File file = new File(makeSwingPropertiesFilename());
-
-                        if (file.exists()) {
-                            // InputStream has been buffered in Properties
-                            // class
-                            FileInputStream ins = new FileInputStream(file);
-                            props.load(ins);
-                            ins.close();
-                        }
+                    // system-specific configuration in /etc:
+                    systemWide = readPropertiesFromFile("/etc/java/swing.properties", installationWide);
+                    
+                    // user-specific configuration in user home:
+                    String userHome = System.getProperty("user.home");
+                    if (userHome != null) {
+                        userWide = readPropertiesFromFile(userHome + "/.config/java/swing.properties", systemWide);
                     }
-                    catch (Exception e) {
-                        // No such file, or file is otherwise non-readable.
+                    
+                    if (userWide == null) {
+                        return new Properties();
                     }
 
                     // Check whether any properties were overridden at the
                     // command line.
-                    checkProperty(props, defaultLAFKey);
-                    checkProperty(props, auxiliaryLAFsKey);
-                    checkProperty(props, multiplexingLAFKey);
-                    checkProperty(props, installedLAFsKey);
-                    checkProperty(props, disableMnemonicKey);
+                    checkProperty(userWide, defaultLAFKey);
+                    checkProperty(userWide, auxiliaryLAFsKey);
+                    checkProperty(userWide, multiplexingLAFKey);
+                    checkProperty(userWide, installedLAFsKey);
+                    checkProperty(userWide, disableMnemonicKey);
                     // Don't care about return value.
-                    return null;
+                    return userWide;
                 }
             });
-            return props;
         }
     }
+    
+    private static Properties readPropertiesFromFile(String filePath, Properties defaults) {
+        File file = new File(filePath);
+        if (file.exists() && file.isFile() && file.canRead()) {
+            try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
+                Properties properties = defaults == null ? new Properties() : new Properties(defaults);
+                properties.load(in);
+                return properties;
+            } catch (Exception ignore) {
+                // ignore
+            }
+        }
+        // if we are sill here - there is no file,
+        // we will return defaults regardless if its null or not:
+        return defaults;
+    }
 
     private static void checkProperty(Properties props, String key) {
         // No need to do catch the SecurityException here, this runs
@@ -1412,6 +1420,21 @@ public class UIManager implements Serial
     }
 
 
+    private static void initializeFontDefaults(Properties swingProps) {
+        String fontSizeProperty = swingProps.getProperty("swing.defaultFontSize");
+        if (fontSizeProperty != null) {
+            try {
+                int value = Integer.parseInt(fontSizeProperty);
+                getLAFState().defaultFontSizeTuxjdkSpecific = value;
+                return;
+            } catch (Exception ignore) {
+            }
+        }
+        // if we are still here - something went wrong and we have to use default value:
+        getLAFState().defaultFontSizeTuxjdkSpecific = 9;
+    }
+
+
     /*
      * This method is called before any code that depends on the
      * <code>AppContext</code> specific LAFState object runs.  When the AppContext
@@ -1456,6 +1479,7 @@ public class UIManager implements Serial
     private static void initialize() {
         Properties swingProps = loadSwingProperties();
         initializeSystemDefaults(swingProps);
+        initializeFontDefaults(swingProps);
         initializeDefaultLAF(swingProps);
         initializeAuxiliaryLAFs(swingProps);
         initializeInstalledLAFs(swingProps);
Index: jdk8-tuxjdk/jdk/src/share/classes/javax/swing/plaf/metal/DefaultMetalTheme.java
===================================================================
--- jdk8-tuxjdk.orig/jdk/src/share/classes/javax/swing/plaf/metal/DefaultMetalTheme.java
+++ jdk8-tuxjdk/jdk/src/share/classes/javax/swing/plaf/metal/DefaultMetalTheme.java
@@ -90,30 +90,11 @@ import sun.swing.SwingUtilities2;
  */
 public class DefaultMetalTheme extends MetalTheme {
     /**
-     * Whether or not fonts should be plain.  This is only used if
-     * the defaults property 'swing.boldMetal' == "false".
-     */
-    private static final boolean PLAIN_FONTS;
-
-    /**
      * Names of the fonts to use.
      */
     private static final String[] fontNames = {
         Font.DIALOG,Font.DIALOG,Font.DIALOG,Font.DIALOG,Font.DIALOG,Font.DIALOG
     };
-    /**
-     * Styles for the fonts.  This is ignored if the defaults property
-     * <code>swing.boldMetal</code> is false, or PLAIN_FONTS is true.
-     */
-    private static final int[] fontStyles = {
-        Font.BOLD, Font.PLAIN, Font.PLAIN, Font.BOLD, Font.BOLD, Font.PLAIN
-    };
-    /**
-     * Sizes for the fonts.
-     */
-    private static final int[] fontSizes = {
-        12, 12, 12, 12, 12, 10
-    };
 
     // note the properties listed here can currently be used by people
     // providing runtimes to hint what fonts are good.  For example the bold
@@ -145,32 +126,20 @@ public class DefaultMetalTheme extends M
      * Returns the ideal font size for the font identified by key.
      */
     static int getDefaultFontSize(int key) {
-        return fontSizes[key];
+        int value = UIManager.getDefaultFontSizeTuxjdkSpecific();
+        if (key == SUB_TEXT_FONT) {
+            // doing precise operation and then cutting the tail:
+            double d = value * 0.9d;
+            value = (int) d;
+        }
+        return value;
     }
 
     /**
      * Returns the ideal font style for the font identified by key.
      */
     static int getDefaultFontStyle(int key) {
-        if (key != WINDOW_TITLE_FONT) {
-            Object boldMetal = null;
-            if (AppContext.getAppContext().get(
-                    SwingUtilities2.LAF_STATE_KEY) != null) {
-                // Only access the boldMetal key if a look and feel has
-                // been loaded, otherwise we'll trigger loading the look
-                // and feel.
-                boldMetal = UIManager.get("swing.boldMetal");
-            }
-            if (boldMetal != null) {
-                if (Boolean.FALSE.equals(boldMetal)) {
-                    return Font.PLAIN;
-                }
-            }
-            else if (PLAIN_FONTS) {
-                return Font.PLAIN;
-            }
-        }
-        return fontStyles[key];
+        return Font.PLAIN;
     }
 
     /**
@@ -180,17 +149,6 @@ public class DefaultMetalTheme extends M
         return defaultNames[key];
     }
 
-    static {
-        Object boldProperty = java.security.AccessController.doPrivileged(
-            new GetPropertyAction("swing.boldMetal"));
-        if (boldProperty == null || !"false".equals(boldProperty)) {
-            PLAIN_FONTS = false;
-        }
-        else {
-            PLAIN_FONTS = true;
-        }
-    }
-
     private static final ColorUIResource primary1 = new ColorUIResource(
                               102, 102, 153);
     private static final ColorUIResource primary2 = new ColorUIResource(153,
